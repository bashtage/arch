{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Bootstrap Examples"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_This setup code is required to run in an IPython notebook_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn\n",
    "\n",
    "seaborn.set_style(\"darkgrid\")\n",
    "plt.rc(\"figure\", figsize=(16, 6))\n",
    "plt.rc(\"savefig\", dpi=90)\n",
    "plt.rc(\"font\", family=\"sans-serif\")\n",
    "plt.rc(\"font\", size=14)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sharpe Ratio"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The Sharpe Ratio is an important measure of return per unit of risk.  The example shows how to estimate the variance of the Sharpe Ratio and how to construct confidence intervals for the Sharpe Ratio using a long series of U.S. equity data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import arch.data.frenchdata\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "ff = arch.data.frenchdata.load()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The data set contains the Fama-French factors, including the excess market return."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "            Mkt-RF          SMB          HML           RF\n",
      "count  1109.000000  1109.000000  1109.000000  1109.000000\n",
      "mean      0.659946     0.206555     0.368864     0.274220\n",
      "std       5.327524     3.191132     3.482352     0.253377\n",
      "min     -29.130000   -16.870000   -13.280000    -0.060000\n",
      "25%      -1.970000    -1.560000    -1.320000     0.030000\n",
      "50%       1.020000     0.070000     0.140000     0.230000\n",
      "75%       3.610000     1.730000     1.740000     0.430000\n",
      "max      38.850000    36.700000    35.460000     1.350000\n"
     ]
    }
   ],
   "source": [
    "excess_market = ff.iloc[:, 0]\n",
    "print(ff.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The next step is to construct a function that computes the Sharpe Ratio.  This function also return the annualized mean and annualized standard deviation which will allow the covariance matrix of these parameters to be estimated using the bootstrap."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def sharpe_ratio(x):\n",
    "    mu, sigma = 12 * x.mean(), np.sqrt(12 * x.var())\n",
    "    values = np.array([mu, sigma, mu / sigma]).squeeze()\n",
    "    index = [\"mu\", \"sigma\", \"SR\"]\n",
    "    return pd.Series(values, index=index)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The function can be called directly on the data to show full sample estimates."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "mu        7.919351\n",
       "sigma    18.455084\n",
       "SR        0.429115\n",
       "dtype: float64"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "params = sharpe_ratio(excess_market)\n",
    "params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Reproducibility\n",
    "\n",
    "All bootstraps accept the keyword argument `seed` which can contain a NumPy `Generator` or `RandomState` or an `int`.  When using an `int`, the argument is passed `np.random.default_rng` to create the core generator. This allows the same pseudo random values to be used across multiple runs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### _Warning_\n",
    "\n",
    "_The bootstrap chosen must be appropriate for the data.  Squared returns are serially correlated, and so a time-series bootstrap is required._"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Bootstraps are initialized with any bootstrap specific parameters and the data to be used in the bootstrap.  Here the `12` is the average window length in the Stationary Bootstrap, and the next input is the data to be bootstrapped."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA6kAAAF7CAYAAAAwts2+AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8QVMy6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAtKElEQVR4nO3df3BV5Z0/8E8ISQgNGIuBXRaL/FBQaAMiTJW6WNeKgKUVtLq2/sKfUBfHoohYldZVGS06VoVWi1KLRShlYS1d62i1dqvUKgjdCi4BBWqVBijFQORCuN8//JptikDivUlObl6vmcx4n+fkOZ/jPJx73jm/8tLpdDoAAAAgAdo0dwEAAADwISEVAACAxBBSAQAASAwhFQAAgMQQUgEAAEgMIRUAAIDEaNvcBQBArquoqIhZs2bFb3/729i+fXscdthhcfzxx8e4ceNi4MCBERGxaNGiuPHGG/f73cLCwjjiiCNi6NCh8Y1vfCM++clPNnX5ANCkhFQAaERr166Nc889N4477riYPHlylJWVRWVlZcyfPz+++tWvxoMPPhif//zna5e/9957o3PnzrWfd+7cGcuXL4/Zs2dHRUVFPPHEE82xGQDQZIRUAGhEjz76aJSUlMQjjzwShYWFte1nnHFGjBkzJu655546IbVfv37RvXv3OmMMGzYsampq4uGHH46Kioro3bt3k9UPAE1NSAWARrR169bIy8vbr72wsDCuv/762LBhQ73G6dixY7ZLA4BEElIBoBGdeuqp8fzzz8e5554bZ599dnz2s5+NXr16RcQHZ0j/Xk1NTezdu7f283vvvRe//e1vY/bs2fGZz3wmevbs2WS1A0BzEFIBoBGde+65UVlZGT/4wQ/i29/+dkREHH744XHiiSfGueeeG5/97GfrLD9ixIj9xigtLY1/+Zd/ieuuuy7atPFgfgByW146nU43dxEAkOuqqqriN7/5TSxbtixefvnlqKioiIiIcePGxQ033FD7dN8HH3wwunTpEnv37o2f//zn8fjjj8fVV18dEyZMaOYtAICm4UwqADSBkpKSGD58eAwfPjwiItavXx/f/OY345FHHomzzjqrdrmjjz669sFJAwcOjMLCwrjvvvuiqKgoLr300mapHQCakmuGAKCRvPvuu3HiiSfG448/vl9fz549Y+rUqRERtWdVP8o111wTvXr1invv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a9e4RdLqNWSefujdd9+NcePGRZs2beK73/1u7WXq0FjqO0/ff//9+OY3vxk333xzdOjQoUlrpHVryL40Pz8/jjnmmPjGN74RERHHHXdcvPrqq7FgwYLo379/0xRMq9SQeTp79uxIpVJxzTXXRMQH87SioiJmzZoV3//+95umYPgIjjoz1KVLl9ixY0ednUFlZWUUFhbGYYcdtt+ylZWVddq2bNkSZWVlTVIrrVdD5mlExKZNm+L888+PvLy8+NGPfhSHH354U5ZLK1Xfebpq1arYsGFDTJ48OQYOHBgDBw6MP//5z3HrrbfGLbfc0hyl00o0ZF/auXPn6NmzZ522Hj16xJ/+9KcmqZXWqyHz9Pe//30cffTRddr69esXmzZtapJa4UCE1Awde+yxUVBQUOfhR6+++mr069cv2rate6K6vLw8VqxYEel0OiIi0ul0rFixIgYMGNCUJdMKNWSebt++PS655JLo0KFD/OhHP4ojjjiiqcullarvPP3MZz4TTz/9dCxevLj254gjjoiJEyfWng2AxtCQfenAgQP3e3VXRUVF/NM//VOT1Err1ZB52rlz53jjjTfqtK1bty4+9alPNUmtcCBCaoaKi4vjy1/+cnzrW9+KVatWxbPPPhuPPPJIXHjhhRHxwV+u3n///YiIOOOMM2LXrl1x2223RUVFRdx5551RVVUVI0eObM5NoBVoyDy999574y9/+UtMnz49ampqorKyMiorK+O9995rzk2gFajvPG3Xrl107969zk+bNm2iU6dO0alTp2beCnJZQ/al5557brz55ptx9913x8aNG2POnDnx0ksvxbnnntucm0Ar0NB5+rvf/S4efvjh2LRpU/zkJz+JRYsWxUUXXdScmwDek5oNu3btSk+ePDk9YMCA9NChQ9OzZ8+u7TvmmGPqvLtv5cqV6S9/+cvp/v37p8eOHZv+/e9/3xwl0wrVd54OGTIkfcwxx+z3M2nSpOYqnVakIfvTv3XyySd7TypNoiFzdMWKFemxY8em+/fvnx4xYkT6mWeeaY6SaYUaMk+ff/759FlnnZUeMGBA+swzz0w/9dRTzVEy1JGXTv//a08BAACgmbncFwAAgMQQUgEAAEgMIRUAAIDEEFIBAABIDCEVAACAxBBSAQAASAwhFQAAgMQQUgEAAEgMIRUAAIDE+H8W+hPUu7GX9QAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 1152x432 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from arch.bootstrap import StationaryBootstrap\n",
    "\n",
    "# Initialize with entropy from random.org\n",
    "entropy = [877788388, 418255226, 989657335, 69307515]\n",
    "seed = np.random.default_rng(entropy)\n",
    "\n",
    "bs = StationaryBootstrap(12, excess_market, seed=seed)\n",
    "results = bs.apply(sharpe_ratio, 2500)\n",
    "SR = pd.DataFrame(results[:, -1:], columns=[\"SR\"])\n",
    "fig = SR.hist(bins=40)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             mu     sigma        SR\n",
      "mu     3.837196 -0.638431  0.224722\n",
      "sigma -0.638431  3.019569 -0.105762\n",
      "SR     0.224722 -0.105762  0.014915\n",
      "\n",
      "\n",
      "mu       1.958876\n",
      "sigma    1.737691\n",
      "SR       0.122126\n",
      "Name: Std Errors, dtype: float64\n"
     ]
    }
   ],
   "source": [
    "cov = bs.cov(sharpe_ratio, 1000)\n",
    "cov = pd.DataFrame(cov, index=params.index, columns=params.index)\n",
    "print(cov)\n",
    "se = pd.Series(np.sqrt(np.diag(cov)), index=params.index)\n",
    "se.name = \"Std Errors\"\n",
    "print(\"\\n\")\n",
    "print(se)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              mu      sigma        SR\n",
      "Lower   4.367662  14.780547  0.166759\n",
      "Upper  11.958503  21.735752  0.659350\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(sharpe_ratio, 1000, method=\"basic\")\n",
    "ci = pd.DataFrame(ci, index=[\"Lower\", \"Upper\"], columns=params.index)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Alternative confidence intervals can be computed using a variety of methods.  Setting `reuse=True` allows the previous bootstrap results to be used when constructing confidence intervals using alternative methods."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              mu      sigma        SR\n",
      "Lower   3.880198  15.174416  0.198880\n",
      "Upper  11.471040  22.129620  0.691471\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(sharpe_ratio, 1000, method=\"percentile\", reuse=True)\n",
    "ci = pd.DataFrame(ci, index=[\"Lower\", \"Upper\"], columns=params.index)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Optimal Block Length Estimation\n",
    "\n",
    "The function `optimal_block_length` can be used to estimate the optimal block lengths for the Stationary and Circular bootstraps. Here we use the squared market return since the Sharpe ratio depends on the mean and the variance, and the autocorrelation in the squares is stronger than in the returns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "        stationary   circular\n",
      "Mkt-RF   47.766787  54.679322\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import optimal_block_length\n",
    "\n",
    "opt = optimal_block_length(excess_market**2)\n",
    "print(opt)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can repeat the analysis above using the estimated optimal block length.  Here we see that the extremes appear to be slightly more extreme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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uGG7+6xYsSK/+MUvctZZZ3WNPf744xk/frzACgAAwBuyU1daTzrppNfd55/+6Z9y9NFHZ7/99usaa25uTnV1dT75yU/mkUceyd57750vfvGLaWpqeuMVAwAAMGT06EZM2/PHP/4xd999d66//vpu448//njWr1+fL3zhCxk3blyWLl2aj3/84/npT3+a8ePHb3e+6uqqNDSMTHX1sDQ0jKxEidAv9DAUh3+LQ5PzMIOBPmagK7eHKxJab7vttrzlLW/Z6grqokWLsnHjxowaNSpJcv755+eBBx7ITTfdlDPPPHO783V2ltLauiENDSPT2rqhEiVCv9DDVEJj4+jX34nX5d/i0OQ8zGCgjxnottXDPfl8U5HQevfdd+foo4/earympqbb91mrqqoyYcKE/OlPf6rEYQGg34zapT71dRX5M5okad+4OW3r2ys2HwAMFmX/tS2VSnnooYcye/bsrbZ9+MMfztFHH51Pf/rTSZItW7bkscce26nvyAJAkdXXDc9bF9xasfmeWjgjbRWbDQAGj7JD69NPP52XXnop++6771bb3vve92bJkiXZf//9s+eee+bqq6/O//3f/2XWrFnlHhYAAIAhoOzQ+vzzzydJdt111622nXHGGdmyZUvOO++8vPDCC2lqasrVV1/d7dmuAAAAsD09Dq2PPfZYt9dNTU1bjb2quro6c+fOzdy5c99YdQAAAAxpw/q7AAAAANgeoRUAAIDCEloBAAAoLKEVAACAwhJaAQAAKCyhFQAAgMIq+zmtAFB0L2/qTGOjZ4QDwEAktAIw6I2oqc5bF9xa0TmfWjijovMBANtmeTAAAACF5UorQIWN2qU+9XVOrwAAleBTFUCF1dcNr+hSVMtQAYChzPJgAAAACktoBQAAoLCEVgAAAApLaAUAAKCwhFYAAAAKS2gFAACgsIRWAAAACktoBQAAoLCEVgAAAApLaAUAAKCwhFYAAAAKS2gFAACgsIRWAAAACktoBQAAoLCEVgAAAApreH8XAAAkL2/qTGPj6IrN175xc9rWt1dsPgDoL0IrABTAiJrqvHXBrRWb76mFM9JWsdkAoP/0aHlwR0dHjj322Nxzzz1dY+ecc07233//bj9XX3111/bly5fngx/8YJqamnLyySdn9erVFSseAACAwW2nr7Ru3Lgx8+bNy6pVq7qNNzc3Z/78+TnuuOO6xkaNGpUkeeaZZ3LGGWdkzpw5ed/73pfvfOc7mTNnTm655ZYMG+brtAAAAOzYTiXH5ubm/N3f/V3WrFmz1bYnnngikyZNSmNjY9dPfX19kmTp0qU54IAD8qlPfSoTJ07MRRddlGeeeSbLly+v7LsAAABgUNqp0Hrffffl8MMPzw033NBtvKWlJa2trdl77723+XsrV67MIYcc0vW6vr4+Bx10UFasWFFGyQAAAAwVO7U8+KSTTtrmeHNzc4YPH57LLrssd999d3bbbbeccsopmTlzZpJXQu3YsWO7/c6YMWPy3HPP7fB41dVVaWgYmerqYWloGLkzJUIh6WGgPzn/OA8zOOhjBrpye7isuwc/8cQTSZIDDjggJ598cu69996ce+65qa+vz7Rp09Le3p7a2tpuv1NbW5uOjo4dztvZWUpr64Y0NIxMa+uGckqEfqWHh6ZKPrYEyuH84zzM4KCPGei21cM9+bxUVmj9yEc+khkzZqShoSHJK+F19erVue666zJt2rTU1dVtFVA7Ojq69gcAAIAdKesWvlVVVVsF0AkTJnQt/x03blxaWlq6bV+3bl0aGxvLOSwAAABDRFmhdeHChTnttNO6jT3yyCOZMGFCkqSpqSkPPPBA17b29vY8/PDDmTx5cjmHBQAAYIgoK7QeeeSRufvuu/PDH/4wa9asybXXXpubbropp556apJk1qxZWblyZa644oo0Nzfny1/+cvbYY48ceuihFSkeAACAwa2s0Dp16tQsWrQoS5cuzYwZM3Lttdfmm9/8Zt75zncmScaPH5/LL788N998c2bNmpV169Zl8eLFGTasrMMCAAAwRPT4RkyPPfZYt9fTp0/P9OnTt7v/EUcckSOOOKLnlQEAADDkueQJAABAYQmtAAAAFJbQCgAAQGEJrQAAABSW0AoAAEBhCa0AAAAUltAKAABAYQmtAAAAFJbQCgAAQGEJrQAAABSW0AoAAEBhCa0AAAAUltAKAABAYQmtAAAAFJbQCgAAQGEJrQAAABSW0AoAAEBhCa0AAAAUltAKAABAYQmtAAAAFJbQCgAAQGEJrQAAABSW0AoAAEBhCa0AAAAUltAKAABAYQmtAAAAFJbQCgAAQGH1KLR2dHTk2GOPzT333NM19pvf/CazZs3KwQcfnGOOOSY//vGPu/3OMccck/3337/bzyOPPFKZ6gEAABjUhu/sjhs3bsy8efOyatWqrrGnnnoqp512WubMmZNp06Zl5cqV+fKXv5wxY8bkyCOPTEdHR9auXZvrrrsue+65Z9fv7bbbbpV9FwAAAAxKOxVam5ubM2/evJRKpW7jP/vZz/K2t70tp59+epJkr732yu9+97vccsstOfLII/PEE0+kqqoqb3/721NTU1P56gEAABjUdmp58H333ZfDDz88N9xwQ7fxadOm5Zxzzuk2VlVVlY0bNyZJHn/88YwfP15gBQAA4A3ZqSutJ5100jbH9957726v161bl1tvvTVnnnlmkleu0FZXV+eTn/xkHnnkkey999754he/mKampjLLBgAAYCjY6e+0vp4NGzbkzDPPzNixY7tC7uOPP57169fnC1/4QsaNG5elS5fm4x//eH76059m/Pjx252ruroqDQ0jU109LA0NIytVIvQ5PQz0J+cf52EGB33MQFduD1cktL744os57bTT8j//8z/5l3/5l9TX1ydJFi1alI0bN2bUqFFJkvPPPz8PPPBAbrrppq6rsdvS2VlKa+uGNDSMTGvrhkqUCP1CDw9NjY2j+7sESBLnnzgPMzjoYwa6bfVwTz4vlR1aX3jhhZx66qlZt25dfvjDH+Ytb3lL17aamppu32etqqrKhAkT8qc//ancwwIAADAE9Og5ra/V0dGR008/Pf/7v/+ba6+9NhMmTOi2/cMf/nCuvPLKrtdbtmzJY489ttV+AAAAsC1lXWm9+uqr84c//CH//M//nPr6+rS0tCR55QprQ0ND3vve92bJkiXZf//9s+eee+bqq6/O//3f/2XWrFkVKR6gEkbtUp/6uop9xR8AgAoq61Pabbfdls2bN+eUU07pNv6Od7wj1113Xc4444xs2bIl5513Xl544YU0NTXl6quvzujRvu8FFEd93fC8dcGtFZvvqYUzKjYXAMBQ1+PQ+thjj3X994033rjDfaurqzN37tzMnTu355UBAG/Yy5s6K3pTsPaNm9O2vr1i8wHAzrIeDgAGoRE11RVfQdBWsdkAYOeVdSMmAAAA6E1CKwAAAIUltAIAAFBYQisAAACFJbQCAABQWEIrAAAAhSW0AgAAUFhCKwAAAIUltAIAAFBYQisAAACFJbQCAABQWEIrAAAAhSW0AgAAUFhCKwAAAIUltAIAAFBYQisAAACFJbQCAABQWEIrAAAAhSW0AgAAUFhCKwAAAIUltAIAAFBYQisAAACFJbQCAABQWEIrAAAAhSW0AgAAUFhCKwAAAIXVo9Da0dGRY489Nvfcc0/X2NNPP53Zs2dn8uTJmTZtWn75y192+53ly5fngx/8YJqamnLyySdn9erVlakcAACAQW+nQ+vGjRvz+c9/PqtWreoaK5VKmTNnThoaGrJs2bIcf/zxmTt3btauXZskeeaZZ3LGGWfkuOOOy09+8pPsvvvumTNnTrZs2VL5dwIAAMCgs1Ohtbm5OX/3d3+XNWvWdBtfvnx5nnzyyXzta1/LxIkT8+lPfzoHH3xwli1bliRZunRpDjjggHzqU5/KxIkTc9FFF+WZZ57J8uXLK/9OAAAAGHR2KrTed999Ofzww3PDDTd0G1+5cmUOPPDAjBo1qmtsypQpefDBB7u2H3LIIV3b6uvrc9BBB2XFihUVKB0AAIDBbvjO7HTSSSdtc7ylpSVjx47tNjZmzJg8++yzO9z+3HPPvZFaAQAAGGJ2KrRuT3t7e2pqarqN1dbWZtOmTV3ba2trt9re0dGxw3mrq6vS0DAy1dXD0tAwspwSoV/pYWAwGYjnM+dhBgN9zEBXbg+XFVrr6urS1tbWbayjoyMjRozo2v7agNrR0ZGGhoYdztvZWUpr64Y0NIxMa+uGckqEfqWHB4bGxtH9XQIU3subOjOiprqic7Zv3Jy29e0VnfO1nIcZDPQxA922ergnn7/KCq3jxo3Lo48+2m1s3bp1aWxs7Nre0tKy1fZ99923nMMCAH1sRE113rrg1orO+dTCGWl7/d0AGOJ69JzW12pqasqjjz6aDRv+X2q+//77M3ny5K7tDzzwQNe29vb2PPzww13bAQAAYEfKCq1Tp07NHnvskQULFmTVqlW58sors3LlypxwwglJklmzZmXlypW54oor0tzcnC9/+cvZY489cuihh1akeAAAAAa3skJrdXV1Fi9enBdeeCEzZ87MzTffnG9/+9sZP358kmT8+PG5/PLLc/PNN2fWrFlZt25dFi9enGHDyjosAAAAQ0SPv9P62GOPdXu911575Zprrtnu/kcccUSOOOKInlcGAADAkOeSJwAAAIVV1t2DAfraqF3qU1/n1AUAMFT45AcMKPV1w3vlsRsAABST5cEAAAAUltAKAABAYVkeDAD0i5c3daaxcXTF5mvfuDlt69srNh8AxSC0AgD9YkRNdUW/o/7Uwhlpq9hsABSF5cEAAAAUltAKAABAYQmtAAAAFJbQCgAAQGEJrQAAABSW0AoAAEBhCa0AAAAUltAKAABAYQmtAAAAFJbQCgAAQGEJrQAAABTW8P4uABjcRu1Sn/o6pxoAAN4YnySBXlVfNzxvXXBrxeZ7auGMis0FAEDxWR4MAABAYQmtAAAAFJbQCgAAQGEJrQAAABSW0AoAAEBhCa0AAAAUltAKAABAYZX9nNYbb7wxZ5111ja33XnnnbniiiuydOnSbuNnnXVWTjnllHIPDQAAwCBXdmidPn163vOe93S93rJlS84444yMHz8+e+yxR5qbmzN//vwcd9xxXfuMGjWq3MMCAAAwBJQdWkeMGJERI0Z0vb7mmmvyxz/+MVdddVWS5IknnsikSZPS2NhY7qGAPjBql/rU15V9agAAgIqo6CfTtra2fPvb387cuXOz6667pqWlJa2trdl7770reRigF9XXDc9bF9xasfmeWjijYnMBADD0VPRGTDfccENqa2tzwgknJEmam5szfPjwXHbZZXnPe96T4447LjfeeGMlDwkAAMAgVrErraVSKTfccEM++tGPpqamJskrS4OT5IADDsjJJ5+ce++9N+eee27q6+szbdq07c5VXV2VhoaRqa4eloaGkZUqEfqcHgboW6895zoPMxjoYwa6cnu4YqH1D3/4Q9asWZO//du/7Rr7yEc+khkzZqShoSHJK+F19erVue6663YYWjs7S2lt3ZCGhpFpbd1QqRKhzw3EHm5sHN3fJQC8Ya895w7E8zC8lj5moNtWD/fkM2fFlgfffffdaWpqyrhx47rGqqqqugLrqyZMmJDnnnuuUocFAABgEKtYaF25cmUOOeSQbmMLFy7Maaed1m3skUceyYQJEyp1WAAAAAaxioXWVatWZeLEid3GjjzyyNx999354Q9/mDVr1uTaa6/NTTfdlFNPPbVShwUAAGAQq1hoXbdu3VZLgadOnZpFixZl6dKlmTFjRq699tp885vfzDvf+c5KHRYAAIBBrGI3YnrooYe2OT59+vRMnz69UocBAABgCKnoc1oBAACgkoRWAAAACktoBQAAoLCEVgAAAAqrYjdiAgDoTy9v6kxj4+itxrc1tjPaN25O2/r2cssCoExCKwAwKIyoqc5bF9xasfmeWjgjbRWbDYA3yvJg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55xzcsghh+Twww/P9773ve3u++ijj+bEE09MU1NTZs6cmYceeqgPK4Vt60kP/+xnP8uxxx6byZMn57jjjst//Md/9GGlsG096eFXtba25rDDDsuNN97YBxXCjvWkhx9//PF87GMfS1NTU4455pj8/Oc/78NKYft60sf33XdfZs6cmcmTJ+dv//Zv85//+Z99WCnsWEdHR4499tjcc889293njeS6fg2tl1xySVasWJGrrroqX/3qV3PFFVfk1lu3fqjuhg0b8slPfjJNTU258cYbM2XKlJx22mlpaxssj8tloNrZHr7vvvsyf/78fOxjH8vNN9+cD3/4w/nHf/zHPPzww/1QNfw/O9vDf+6iiy7K888/30cVwo7tbA+/9NJL+cQnPpG/+Iu/yM0335x/+Id/yLx589Lc3NwPVUN3O9vHzz//fE4//fR84AMfyL/9279l2rRp+cxnPpOnn366H6qG7jZu3JjPf/7zWbVq1Xb3ecO5rtRPXnrppdLb3/720q9//euuse985zulk046aat9f/zjH5fe+973ljo7O0ulUqm0ZcuW0vvf//7S0qVL+6xeeK2e9PDZZ59d+tznPtdt7BOf+ETp61//eq/XCdvTkx5+1V133VU65phjSu9617tKP/nJT/qiTNiunvTwNddcU3rf+95X6ujo6Br79Kc/7bME/a4nfXz77beXpkyZ0m1s6tSppVtvvbXX64QdWbVqVem4444rffCDHyztt99+3fr5z73RXNdvV1offfTRdHR0ZMqUKV1jU6ZMye9///ts3ry5274rV67MO97xjgwb9kq5VVVVecc73tHtUTrQ13rSwyeffHLmzJnTbayqqiobN27sk1phW3rSw0nS1taW888/PxdccEFqamr6slTYpp708G9/+9sceeSR3Xr3u9/9bk444YQ+qxe2pSd93NDQkBdffDH//u//nlKplF/84hd56aWXsv/++/d12dDNfffdl8MPPzw33HDDDvd7o7mu30JrS0tLdt1119TV1XWN7b777tm0aVNeeOGFrfYdO3Zst7ExY8bkueee65NaYVt60sMHHHBAJk6c2PV61apV+c1vfpNDDjmkz+qF1+pJDyfJ17/+9bznPe/RtxRGT3p4zZo1GTNmTM4///y8+93vzvHHH58777yzr0uGrfSkj9/5znfmox/9aD73uc/loIMOymc+85mcd9552Wefffq6bOjmpJNOyvz581NfX7/D/d5oruu30Nre3p7a2tpuY6++7ujo2Kl9X7sf9KWe9PCfe/7553PmmWdmypQpOeqoo3q1RtiRnvTwvffemzvvvDNf/OIX+6w+eD096eGXXnopS5YsyS677JIrr7yy67uA//Vf/9Vn9cK29KSPN2zYkP/5n//JGWeckWXLluULX/hCLrroojz44IN9VS6U5Y3muuG9WdSO1NXVbVXcq69fm9C3t++IESN6t0jYgZ708KueffbZzJ49O8OGDcu3vvWtrqUR0B92todffvnlfOUrX8k555yT0aNH92mNsCM9OQ9XV1dnv/32y+c///kkyYEHHpj7778/S5cuzaRJk/qmYNiGnvTxkiVL0tHRkc9+9rNJXunj5ubmXHHFFfnud7/bNwVDGd5oruu3T8zjxo3L+vXruxXd0tKS2tra7Lrrrlvt29LS0m1s3bp1aWxs7JNaYVt60sNJsnbt2nzkIx9JVVVVfvSjH2W33Xbry3JhKzvbww899FBWr16d+fPn5+CDD87BBx+cP/3pTznvvPNy7rnn9kfpkKRn5+GxY8dmwoQJ3cb23nvv/PGPf+yTWmF7etLHv//977Pvvvt2GzvooIOydu3aPqkVyvVGc12/hda3ve1tqamp6fal2/vvvz8HHXRQhg/vfgG4qakpK1asSKlUSpKUSqWsWLEikydP7suSoZue9HBra2s+8YlPZPTo0fnRj36U3Xffva/Lha3sbA//1V/9VW6//fbcdNNNXT+777575s6d2/V/+6E/9OQ8fPDBB2/1mLHm5ub85V/+ZZ/UCtvTkz4eO3ZsHnvssW5jjz/+eN7ylrf0Sa1Qrjea6/ottNbX1+dDH/pQvvrVr+ahhx7KHXfcke9///v52Mc+luSV/8P08ssvJ0k+8IEPZMOGDbngggvS3Nyciy++OG1tbZk+fXp/lQ896uFLL700//u//5uFCxems7MzLS0taWlpyYsvvtifb4Ehbmd7eMSIEdlrr726/QwbNixjxozJmDFj+vldMJT15Dx84okn5sknn8zXv/71rFmzJldffXV+85vf5MQTT+zPtwA97uPf/e53+d73vpe1a9fmxz/+cW688cZ8/OMf78+3ADtUkVxXyefz9NSGDRtK8+fPL02ePLl0+OGHl5YsWdK1bb/99uv2DMCVK1eWPvShD5UmTZpUmjVrVun3v/99f5QM3exsD0+dOrW03377bfUzb968/iodSqVSz87Df+4973mP57RSCD3p4RUrVpRmzZpVmjRpUmnatGmlX/ziF/1RMmylJ3181113lY4//vjS5MmTS8cee2zptttu64+SYbte+5zWSuS6qlLp/782CwAAAAXj1qUAAAAUltAKAABAYQmtAAAAFJbQCgAAQGEJrQAAABSW0AoAAEBhCa0AAAAUltAKAABAYQmtAAAAFNb/BzIVuIaWZnb5AAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 1152x432 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Reinitialize using the same entropy\n",
    "rs = np.random.default_rng(entropy)\n",
    "\n",
    "bs = StationaryBootstrap(opt.loc[\"Mkt-RF\", \"stationary\"], excess_market, seed=seed)\n",
    "results = bs.apply(sharpe_ratio, 2500)\n",
    "SR = pd.DataFrame(results[:, -1:], columns=[\"SR\"])\n",
    "fig = SR.hist(bins=40)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Probit (statsmodels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The second example makes use of a Probit model from statsmodels.  The demo data is university admissions data which contains a binary variable for being admitted, GRE score, GPA score and quartile rank. This data is downloaded from the internet and imported using pandas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "            admit         gre         gpa       rank\n",
      "count  400.000000  400.000000  400.000000  400.00000\n",
      "mean     0.317500  587.700000    3.389900    2.48500\n",
      "std      0.466087  115.516536    0.380567    0.94446\n",
      "min      0.000000  220.000000    2.260000    1.00000\n",
      "25%      0.000000  520.000000    3.130000    2.00000\n",
      "50%      0.000000  580.000000    3.395000    2.00000\n",
      "75%      1.000000  660.000000    3.670000    3.00000\n",
      "max      1.000000  800.000000    4.000000    4.00000\n"
     ]
    }
   ],
   "source": [
    "import arch.data.binary\n",
    "\n",
    "binary = arch.data.binary.load()\n",
    "binary = binary.dropna()\n",
    "print(binary.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fitting the model directly"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first steps are to build the regressor and the dependent variable arrays.  Then, using these arrays, the model can be estimated by calling `fit`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Const   -3.003536\n",
      "gre      0.001643\n",
      "gpa      0.454575\n",
      "dtype: float64\n"
     ]
    }
   ],
   "source": [
    "import statsmodels.api as sm\n",
    "\n",
    "endog = binary[[\"admit\"]]\n",
    "exog = binary[[\"gre\", \"gpa\"]]\n",
    "const = pd.Series(np.ones(exog.shape[0]), index=endog.index)\n",
    "const.name = \"Const\"\n",
    "exog = pd.DataFrame([const, exog.gre, exog.gpa]).T\n",
    "\n",
    "# Estimate the model\n",
    "mod = sm.Probit(endog, exog)\n",
    "fit = mod.fit(disp=0)\n",
    "params = fit.params\n",
    "print(params)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The wrapper function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Most models in statsmodels are implemented as classes, require an explicit call to `fit` and return a class containing parameter estimates and other quantities.  These classes cannot be directly used with the bootstrap methods.  However, a simple wrapper can be written that takes the data as the only inputs and returns parameters estimated using a Statsmodel model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "def probit_wrap(endog, exog):\n",
    "    return sm.Probit(endog, exog).fit(disp=0).params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A call to this function should return the same parameter values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Const   -3.003536\n",
       "gre      0.001643\n",
       "gpa      0.454575\n",
       "dtype: float64"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "probit_wrap(endog, exog)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The wrapper can be directly used to estimate the parameter covariance or to construct confidence intervals."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const           gre       gpa\n",
      "Const  0.397473 -6.641971e-05 -0.102525\n",
      "gre   -0.000066  4.467596e-07 -0.000058\n",
      "gpa   -0.102525 -5.815162e-05  0.039859\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import IIDBootstrap\n",
    "\n",
    "bs = IIDBootstrap(endog=endog, exog=exog)\n",
    "cov = bs.cov(probit_wrap, 1000)\n",
    "cov = pd.DataFrame(cov, index=exog.columns, columns=exog.columns)\n",
    "print(cov)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Const    0.630455\n",
      "gre      0.000668\n",
      "gpa      0.199647\n",
      "dtype: float64\n",
      "T-stats\n",
      "Const   -4.764077\n",
      "gre      2.457413\n",
      "gpa      2.276894\n",
      "dtype: float64\n"
     ]
    }
   ],
   "source": [
    "se = pd.Series(np.sqrt(np.diag(cov)), index=exog.columns)\n",
    "print(se)\n",
    "print(\"T-stats\")\n",
    "print(params / se)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const       gre       gpa\n",
      "Lower -4.214157  0.000360  0.005706\n",
      "Upper -1.622607  0.002906  0.871725\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(probit_wrap, 1000, method=\"basic\")\n",
    "ci = pd.DataFrame(ci, index=[\"Lower\", \"Upper\"], columns=exog.columns)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Speeding things up"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Starting values can be provided to `fit` which can save time finding starting values.  Since the bootstrap parameter estimates should be close to the original sample estimates, the full sample estimated parameters are reasonable starting values.  These can be passed using the `extra_kwargs` dictionary to a modified wrapper that will accept a keyword argument containing starting values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "def probit_wrap_start_params(endog, exog, start_params=None):\n",
    "    return sm.Probit(endog, exog).fit(start_params=start_params, disp=0).params"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const           gre       gpa\n",
      "Const  0.397473 -6.641971e-05 -0.102525\n",
      "gre   -0.000066  4.467596e-07 -0.000058\n",
      "gpa   -0.102525 -5.815162e-05  0.039859\n"
     ]
    }
   ],
   "source": [
    "bs.reset()  # Reset to original state for comparability\n",
    "cov = bs.cov(\n",
    "    probit_wrap_start_params, 1000, extra_kwargs={\"start_params\": params.values}\n",
    ")\n",
    "cov = pd.DataFrame(cov, index=exog.columns, columns=exog.columns)\n",
    "print(cov)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bootstrapping Uneven Length Samples\n",
    "Independent samples of uneven length are common in experiment settings, e.g., A/B testing of a website.  The `IIDBootstrap` allows for arbitrary dependence within an observation index and so cannot be naturally applied to these data sets. The `IndependentSamplesBootstrap` allows datasets with variables of different lengths to be sampled by exploiting the independence of the values to separately bootstrap each component. Below is an example showing how a confidence interval can be constructed for the difference in means of two groups. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0.19450863]\n",
      " [0.49723719]]\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import IndependentSamplesBootstrap\n",
    "\n",
    "\n",
    "def mean_diff(x, y):\n",
    "    return x.mean() - y.mean()\n",
    "\n",
    "\n",
    "rs = np.random.RandomState(0)\n",
    "treatment = 0.2 + rs.standard_normal(200)\n",
    "control = rs.standard_normal(800)\n",
    "\n",
    "bs = IndependentSamplesBootstrap(treatment, control, seed=seed)\n",
    "print(bs.conf_int(mean_diff, method=\"studentized\"))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
